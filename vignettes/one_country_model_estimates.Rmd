---
title: "Getting local one-country estimates"
author: "Hannah Comiskey"
output: html_document
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Run the model for one country only

In this example, we are going to set up the data for a one-country model run. A one-country run is faster than the previously described global model that runs all the countries together. The one-country model uses informative priors for the intercepts and variance-covariance matrix of the rates of change between spline coefficients.

```{r, include=FALSE}
devtools::load_all()
```

# Workflow
To begin, load the library:
```{r, warning = FALSE}
library(mcmsupply)
library(tidyverse)
library(ggplot2)
library(tidybayes)
```

## 1. Load the data 
The data used in the paper is found in the /data folder. A full description of how the dataset was obtained can be found in the associated paper. 

The 'SE_source_data_20' dataset contains  the proportions of modern contraceptives supplied over time by the public and private sectors. The data is calculated using national-level demographic and health surveys (DHS) and is filtered to only include observations with a sample size of 20 women or more. . The dataset contains survey estimates for 30 focus countries participating in FP2030 covering the years 1990 to 2019. 

Column        | Description
------------- | -------------
Country       | The name of the country that the survey observation relates to
Method        | The modern contraceptive method that the survey observation relates to
average_year  | The average of the years the survey was carried out in
Sector | The breakdown of the public and private sectors
proportion    | The proportion supplied by the sector named
SE.proportion | The standard error associated with the proportion estimated in the survey
n             | The number of households used to produce the estimate
Method_collapse | The modern contraceptive method that the survey observation relates to

- For a local run, use the country names as printed below as an input into the package functions. See below for examples. 

World region  | Country
------------- | -------------
Southern Asia | Afghanistan
Western Africa | Benin
Western Africa | Burkina Faso
Middle Africa | Cameroon
Middle Africa | Congo
Middle Africa | Congo Democratic Republic
Western Africa | Cote d'Ivoire
Eastern Africa | Ethiopia
Western Africa | Ghana
Western Africa | Guinea
Southern Asia | India
Eastern Africa | Kenya
Western Africa | Liberia
Eastern Africa | Madagascar
Eastern Africa | Malawi
Western Africa | Mali
Eastern Africa | Mozambique
South-Eastern Asia | Myanmar
Southern Asia | Nepal
Western Africa | Niger
Western Africa | Nigeria
Southern Asia | Pakistan
South-Eastern Asia | Philippines
Eastern Africa | Rwanda
Western Africa | Senegal
Western Africa | Sierra Leone
Eastern Africa | Tanzania
Western Africa | Togo
Eastern Africa | Uganda
Eastern Africa | Zimbabwe


Get the input data and filter the data to include the FP2030 focus countries discussed in the associated paper. 
```{r}
source_data <- mcmsupply::get_data(fp2030=TRUE)
```


## 2. Gather the model inputs before modelling 

Clean the raw DHS data to make it suitable for modelling. This function addresses issues with missingness and tiny standard error values. 

- We also set the name of the country we are interested in estimating here. Its is set as a parameter in the function.

```{r}
FP_subset <- mcmsupply::set_up_jags_data(source_data, mycountry="Kenya")
```

### Apply time indexing to the data and find the most recent year of data (Tstar) in each country
```{r}
n_method <- c("Female Sterilization","Implants", "Injectables", "IUD","OC Pills")
FP_subset <- method_index_fun(FP_subset, n_method)

# Time indexing - important for splines 
all_years <- seq(from = 1990, to = 2025.5, by=0.5)
n_all_years <- length(all_years)

time_index_table <- tibble::tibble(average_year = all_years, index_year = 1:length(all_years))

FP_subset <- FP_subset %>%
  dplyr::mutate(index_year = match(average_year,all_years))

# Get T_star and match_Tstar
T_star <- FP_subset %>%
  ungroup() %>%
  filter(index_year==max(index_year)) %>%
  select(average_year, index_year) %>%
  distinct()

```

### Get inputs for JAGS model
```{r}
t_seq_2 <- floor(FP_subset$index_year) # Time sequence for countries
country_seq <- FP_subset$Country
n_country <- as.character(unique(country_seq)) # Names of countries
n_region <- unique(FP_subset$Region) # Names of regions
n_sector <- c("Public", "Commercial_medical", "Other") # Names of categories
n_obs <- nrow(FP_subset) # Total number of observations
year_seq <- seq(min(t_seq_2),max(t_seq_2), by=1) # Year sequence
n_years <- length(year_seq) # Number of years

# Find the indexes of observations that match to the predicted responses
match_years <- FP_subset$index_year
match_method <- FP_subset$index_method
```

###  Get country-specific basis functions and related elements for JAGS model input
```{r}
nseg=12
Kstar <- vector()
B.ik <- matrix(nrow = length(all_years), ncol = nseg+3)
knots.all <- vector()

for(i in 1:nrow(T_star)) {
  index_msn <- T_star$average_year[i]
  res <- bs_bbase_precise(all_years, lastobs=index_msn, nseg = nseg)
  B.ik <- res$B.ik
  Kstar[i] <- res$Kstar
  knots.all <- res$knots.k
}

K <- dim(res$B.ik)[2]
H <- K-1
```


Plot the basis

```{r}
par(lwd = 3, cex.axis = 1.3, cex.lab = 1.3, cex.main = 1.3, mfrow = c(1,1))
plot(all_years,res$B.ik[,1], type= "n", xaxt="n",
     xlab = "Year",
     ylim = c(0,1), ylab ="Basis Function",
     xlim = range(all_years))
axis(1, at = min(all_years):max(all_years))
abline(v=res$knots.k, col = seq(1, K), lwd = 1)
for (k in 1:K){
  lines(all_years,res$B.ik[,k], type= "l", col = k, lwd = 1)
}

```


###  Prepare local model run parameters

```{r}
local_params <- mcmsupply::get_local_parameters("Kenya")
```

```{r}
jagsdata <- list(y = FP_subset[,c("Public", "Commercial_medical")],
                 se_prop = FP_subset[,c("Public.SE", "Commercial_medical.SE")],
                 alphahat_region = local_params$alphahat_region,
                 tau_alphahat_cms = local_params$tau_alphahat_cms,
                 natRmat = local_params$natRmat, # dwish on inverse
                 natdf = length(n_method)+3,
                 tstar = T_star$index_year, 
                 kstar = Kstar,
                 B.ik = B.ik, 
                 n_years = n_all_years,
                 n_obs = n_obs,
                 K = K,
                 H = H,
                 M_count = length(n_method),
                 matchmethod = match_method,
                 matchyears = match_years
) # Inputs for the JAGS model

jags_pars <- c("P",
               "beta.k",
               "inv.sigma_delta",
               "alpha_cms") # Parameters we wish to observe

```

## 3. Fit the model using the DHS survey data

'run_jags_model' is a wrapper function that:
    1. Determines whether you want a local (one-country) or global model run
    2. Sets up the jags model to run with 150K iterations, 10K burn in observations and thinning to every 70th observation.
    3. The function saves the model results to the '/results' folder in the 'mod_results.RDS' file.

```{r, eval=FALSE}
mymod <- mcmsupply::run_jags_model(jagsdata, jags_pars, local_run=TRUE, mycountry="Kenya")
```

```{r, include=FALSE}
mymod <- readRDS("results/mod_Kenya_results.RDS")
```

## 4. Review the  model output

#### Reference tables for the indexing
Note: We specify the method order as per the method-correlation matrix. Order of countries, methods and methods is important for matching to model estimates.

```{r}
country_index_table <- tibble::tibble(Country = unique(source_data$Country),
                 index_country = 1:length(n_country))

method_index_table <- tibble::tibble(Method = n_method,
                             index_method = 1:length(n_method))

sector_index_table <- tibble::tibble(Sector = c("Public", "Commercial_medical", "Other"),
                             index_sector = 1:3)

all_years <- seq(from = 1990, to = 2025.5, by=0.5)
n_all_years <- length(all_years)
year_index_table <- tibble::tibble(average_year = all_years, 
                           index_year = 1:n_all_years)

```

#### Reshaping data to be used for plotting 

```{r}
FP_subset_long_SE <- FP_subset %>% 
  select(Country, Region, Method, average_year, Commercial_medical.SE, Public.SE, Other.SE) %>%
  rename(Commercial_medical = Commercial_medical.SE , Public = Public.SE, Other = Other.SE) %>%
  gather(Sector, SE.proportion, Commercial_medical:Other, factor_key=TRUE) 

FP_subset_long <- FP_subset %>% 
  select(Country, Region, Method, average_year, Commercial_medical, Public, Other) %>%
  gather(Sector, proportion, Commercial_medical:Other, factor_key=TRUE)

FP_subset_long <- merge(FP_subset_long, FP_subset_long_SE)

# Adding error limits to data using SE
FP_subset_long <- FP_subset_long %>% mutate(
  prop_min = proportion - 2*SE.proportion,
  prop_max = proportion + 2*SE.proportion ) %>%
  mutate(prop_max = ifelse(prop_max > 1, 1, prop_max)) %>%
  mutate(prop_min = ifelse(prop_min < 0, 0, prop_min)) 

```


#### Extract all parameters and get their median, SE and credible intervals
```{r}
sample_draws <- tidybayes::tidy_draws(mymod$BUGSoutput$sims.matrix)
n_iter <- nrow(sample_draws)

my_P_estimates <- sample_draws %>%
  select(`P[1,1,1]`:`P[3,5,72]`) %>%
  tidyr::pivot_longer(`P[1,1,1]`:`P[3,5,72]`,
                        names_to = "params",
                        values_to = "mu_pred"
    ) %>%
    dplyr::mutate(index_sector = as.numeric(substr(params, 3,3))) %>%
    dplyr::mutate(index_method = as.numeric(substr(params, 5,5))) %>%
    dplyr::mutate(index_year = rep(rep(1:n_all_years, each = 3*5), n_iter)) %>%
    dplyr::left_join(year_index_table) %>%
    dplyr::left_join(method_index_table) %>%
    dplyr::left_join(sector_index_table) %>%
    dplyr::select(mu_pred, average_year, Method, Sector) %>%
    dplyr::group_by(Method, Sector, average_year) %>%
    dplyr::mutate(pred_mu = median(mu_pred),
                  lwr_95 = quantile(mu_pred, prob = 0.025),
                  upr_95 = quantile(mu_pred, prob = 0.975),
                  lwr_80 = quantile(mu_pred, prob = 0.1),
                  upr_80 = quantile(mu_pred, prob = 0.9)) %>%
    dplyr::mutate(Country = "Kenya") %>%
    dplyr::select(Country, Method, Sector, average_year, pred_mu, lwr_95, upr_95, lwr_80, upr_80) %>%
  dplyr::distinct()
  
```

## 5.Plot the results for one country

```{r, fig.width=9, fig.height=9}
safe_colorblind_palette <- c("#999999", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")

countrycalc <- my_P_estimates %>% dplyr::filter(average_year <= 2025)

ggplot2::ggplot() + 
  ggtitle("Contraceptive Supply in Kenya") +
  geom_line(data=countrycalc, aes(x=average_year, y=pred_mu, colour=Sector)) +
  geom_point(data=FP_subset_long, aes(x=average_year, y=proportion, colour=Sector))+
  geom_errorbar(data=FP_subset_long, aes(ymin = prop_min, ymax = prop_max, x=average_year,
                                      colour=Sector), width = 1.5) +
  geom_ribbon(data=countrycalc, aes(ymin=lwr_95, ymax=upr_95, x=average_year,
                                    fill=Sector), colour=NA, alpha=0.2 ) +
  labs(y="Proportion of contraceptives supplied", x = "Year") +
  scale_y_continuous(limits=c(0,1))+
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90)) +
  theme(strip.text.x = element_text(size = 8)) +
  scale_colour_manual(values= c("Public" = safe_colorblind_palette[3],
                                "Commercial_medical" = safe_colorblind_palette[1] ,
                                "Other" = safe_colorblind_palette[2])) +
  scale_fill_manual(values=c("Public" = safe_colorblind_palette[3],
                             "Commercial_medical" = safe_colorblind_palette[1] ,
                             "Other" = safe_colorblind_palette[2])) +
  theme(legend.position = "bottom")+
  labs(fill = "Sector") +
  guides(color="none") + 
  facet_wrap(~Method)

```

